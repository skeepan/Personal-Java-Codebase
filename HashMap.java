package structures;

// This line allows us to cast our object to type (E) without any warnings.
@SuppressWarnings("unchecked") 
public class HashMap<K extends Comparable<K>,V>{

    private KeyValuePairLinkedList[] table;
    private int size;
    private int capacity;
    private static final float LOAD_FACTOR = 0.75f; 

    // Hashmap Initialisation
    
    public HashMap() {
        this.capacity = 113;
        this.table = new KeyValuePairLinkedList[capacity];
        this.size = 0;
    }

    /**
     States the number of values stored in the hashmap
      
     @return The number of values stored in the hashmap
     */
    public int size() {
        return size;
    }
    
    /**
     Creates the bucket for a given hashmap location:
     It is a KeyValuePairLinkedList which stores multiple KeyValuePair<K, V>.
     Is is iterated via a ListElement<KeyValuePair>
     
     @return void
     */
    protected void initTable(int i) {
        if (table[i]==null) table[i] = new KeyValuePairLinkedList<>();
    }
    
    /**
     Returns the hashcode for a given key using the java .hashCode() method.
     
     @return The integer hashcode generated by java's .hashCode()
     */
    protected int hash(K key) {
        int code = key.hashCode();
        return code;    
    }

    /**
    Resize the table to increase its capacity.
    This method doubles the capacity of the table and rehashes all key-value pairs to the new table.
    
    @return void
    */
    private void resize() {
        // Create a new table with double the capacity
        KeyValuePairLinkedList[] newTable = new KeyValuePairLinkedList[table.length * 2];
        // Updates the capacity 
        capacity = capacity*2;
        // Copy the old table to a temporary variable
        KeyValuePairLinkedList[] temp = table;
        // Set the table reference to the new table
        table = newTable;
        // Rehash all key-value pairs to the new table by iterating through each KeyValuePairLinkedList<>
        for (KeyValuePairLinkedList currentKVPLinkedList : temp) {
            if (currentKVPLinkedList!=null) {
                ListElement<KeyValuePair> ptr = currentKVPLinkedList.getHead();
                while(ptr != null){
                    // Add each key-value pair to the new table using the add() method
                    this.add((K)ptr.getValue().getKey(), (V)ptr.getValue().getValue());
                    ptr = ptr.getNext();
                } 
            }
        }
    }

  
    /**

    Adds a key-value pair to the hash table. If the size of the hash table exceeds the load factor threshold,

    the hash table is resized to double its current size.

    @param key the key of the key-value pair added
    @param value the value of the key-value pair added
    @return void
    */
    public void add(K key, V value) {

        // Check if the size of the hashmap exceeds the load factor threshold and resize the table if necessary
        if (size > LOAD_FACTOR * table.length) {
        resize();
        }
        
        // Increment the size of the table
        this.size++;
        
        // Compute the hash code and table location for the key
        int hash_code = hash(key);
        int location = hash_code % table.length;
        
        // Handle negative locations by wrapping them around to the end of the table
        if (location<0) location = location+table.length;
        
        // Initialize the bucket at the given location if it hasn't been initialized yet
        initTable(location);
        
        // Add the key-value pair to the KeyValuePair linked list at the given location in the table
        table[location].add(key,value);
    }



    /**

    Retrieves the value associated with the given key from the hash table.

    @param key the key to search for in the hash table
    @return the value associated with the given key, or null if the key is not found in the hash table
    */
    public V get(K key) {
        int hash_code = hash(key);
        int location = hash_code % table.length;
        if (location<0) location = location+table.length;

        if (table[location] == null) {
            // if there is no bucket at the given location, the key is not in the hash table
            return null;
        }
        if (table[location].get(key) == null) {
            // if the key is not found in the KeyValuePair linked list bucket, the key is not in the hash table
            return null;
        }
        return (V)table[location].get(key).getValue();
    }

    /**

    Overwrites the value associated with the given key in the hash table with a new value.

    If the key is not found in the hash table, this method does nothing.

    @param key the key whose associated value is to be overwritten
    @param newValue the new value to be associated with the key
    */
    public void overwrite(K key, V newValue) {
        int hash_code = hash(key);
        int location = hash_code % table.length;
        if (location<0) location = location+table.length;

        // Remove the existing key-value pair and add the new value for the given key
        table[location].remove(key);
        table[location].add(key, newValue);
    }

    /**
    Removes a key-value pair from the hash table given a key.

    @param key the key of the key-value pair to be removed
    @return true if the key-value pair is removed, false otherwise
    */
    public boolean remove(K key) {
        int hash_code = hash(key);
        int location = hash_code % table.length;
        return table[location].remove(key);
    }

    /**
     Returns capacity
     
     @return capacity of hashmap
     */
    public int capacity() {
        return this.capacity;
    }
    
    /**

    Returns all the data in the hash table as an array of KeyValuePairLinkedLists.
    Each KeyValuePairLinkedList in the array contains all the key-value pairs stored in the corresponding
    location of the hash table.
    This array omitts all null locations in the hashmap.

    @return an array of KeyValuePairLinkedLists containing all the data in the hash table.
*/

    public KeyValuePairLinkedList[] returnAllData() {
        // Create an array with size equal to the number of elements in the hash table
        KeyValuePairLinkedList[] returnData = new KeyValuePairLinkedList[this.size];
        // Iterate through each location in the hash table
        int InsertionIndex = 0;
        for (int i = 0; i < table.length; i++) {
            // If the current location in the hash table is not null, add the 
            // corresponding KeyValuePairLinkedList to the returnData array
            if (table[i]!= null) {
                returnData[InsertionIndex] = table[i];
                InsertionIndex++;
            }
        }   
        // Return the array of KeyValuePairLinkedLists containing all the data in the hash table
        return returnData;
    }

    /**

    Returns an array of all the unique keys in the HashMap.

    @return an Object array containing all the unique keys in the HashMap
    */
    public Object[] getAllUniqueKeys() {
        // Get all the KeyValuePairLinkedList in the HashMap
        KeyValuePairLinkedList[] allMapData = this.returnAllData(); 
        // Initialize a list to store unique keys
        CustomArrayList<K> allUniqueKeys = new CustomArrayList<K>(); 
        
         // Iterate through each bucket
        for (KeyValuePairLinkedList keyValuePairLinkedList : allMapData) {     
            // Get the first Key Value pair stored at the location 
            // and iterate through each Key Value pair in the bucket
            ListElement<KeyValuePair<K, V>> currentKeyKVP = keyValuePairLinkedList.getHead(); 
            while (currentKeyKVP!=null) {
                //Grab the Key and add it to the list of all keys.
                K key = currentKeyKVP.getValue().getKey();
                allUniqueKeys.add(key);

                //Get the next Key Value pair in this bucket
                currentKeyKVP = currentKeyKVP.getNext();    
            }
            
        }

        return allUniqueKeys.toArray();
    }
   

}   
